# SortAlgorithm
基于C++实现的十大排序算法

# 十大排序算法总结
## 比较类排序
### 冒泡排序
`算法流程`
1. 比较相邻的两个元素，如果前一个元素大于后一个元素，就交换这两个元素的位置；
2. 对每一对相邻的元素重复以上操作，从左往右依次进行，每一轮结束后未排序部分的最大元素“冒泡”到右端；
3. 重复执行步骤1和步骤2，直到所有元素都排序完成。

冒泡排序的时间复杂度为O(n^2)，空间复杂度为O(1)。其中n是待排序元素的数量。是一种稳定的排序算法。
### 快速排序
`算法流程`
1. 选择一个基准元素pivot（一般是序列的第一个元素）；
2. 通过一次 partition 操作将序列分为两个部分，其中左边的部分都小于等于基准元素，右边的部分都大于等于基准元素；
3. 对左右两部分递归进行步骤 1 和步骤 2 的操作，直到排序完成。

快速排序的时间复杂度为 O(nlogn)，空间复杂度为 O(logn)。其中，时间复杂度的最好情况是 O(nlogn)，即每次 partition 操作将序列平分；最坏情况是 O(n^2)，即每次 partition 操作只能将序列分成一个元素和其余元素两个部分。平均情况下，快速排序的时间复杂度为 O(nlogn)。快速排序不稳定。
### 插入排序
`算法流程`
1. 从第一个元素开始，该元素可以认为已经被排序；
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；
4. 重复步骤3，直到找到已排序的元素中小于或者等于新元素的位置；
5. 将新元素插入到该位置后；
6. 重复步骤2~5，直到所有元素都被排序完毕。

插入排序的时间复杂度为O(n^2)，其中n为待排序序列的长度，空间复杂度为O(1)。在实际应用中，插入排序常常用来对一些部分有序的序列进行排序，其优势在于对于小规模的数据集排序非常高效。插入排序是稳定的。
### 希尔排序
`算法流程`
1. 选择一个增量序列（例如：n/2，n/4，…，1）。
2. 对于每个增量，将待排序序列分成若干个子序列，分别对每个子序列进行插入排序。
3. 逐步缩小增量，重复步骤 2，直至增量为 1。

希尔排序的时间复杂度是O(n^2)到O(nlogn)之间，具体取决于增量序列的选择。空间复杂度为O(1)。因为希尔排序是一种原地排序算法，只需要常数级别的额外空间。希尔排序不稳定。
### 选择排序
`算法流程`
1. 从序列中找出最小的元素，将其放到序列的起始位置。
2. 从剩余未排序的元素中继续选择最小的元素，放到已排序序列的末尾。
3. 重复第二步，直到所有元素都排序完毕。

选择排序的时间复杂度为O(n^2)，空间复杂度为O(1)。尽管其时间复杂度和冒泡排序相同，但是选择排序的交换次数要比冒泡排序少得多，因此实际效率会比冒泡排序高一些。不过，在实际应用中，选择排序的效率远远低于快速排序、归并排序等高级排序算法。选择排序不稳定。
### 堆排序
`算法流程`
1. 将待排序序列构建成一个大根堆（或小根堆）。
2. 将堆顶元素与堆末尾元素交换。
3. 对剩余元素重新进行堆化，得到新的堆顶元素。
4. 重复步骤 2 和 3 直到所有元素都有序排列。

堆排序的时间复杂度为 O(nlogn)，空间复杂度为 O(1)。它是一种不稳定的排序算法，因为在堆化的过程中，相同元素的相对顺序可能会发生变化。
### 归并排序
`算法流程`
归并排序是一种基于分治思想的排序算法，其主要步骤可以概括为“分、治、合”三个阶段：
1. 分阶段：将待排序序列递归地分成左右两个子序列，直到子序列的长度为1。
2. 治阶段：将左右两个子序列分别排序。
3. 合并阶段：将排好序的左右子序列合并成一个有序序列。

归并排序的时间复杂度为O(nlogn)，空间复杂度为O(n)。归并排序是稳定的。
## 非比较类排序
### 计数排序
`算法流程`
1. 找出待排序数组的最大值max和最小值min；
2. 开辟一个新的数组count，长度为max-min+1，用于统计待排序数组中每个元素出现的次数；
3. 遍历待排序数组，统计每个元素出现的次数，存入count数组中；
4. count数组中下标i处存放的是值为i+minValue的元素在待排序数组中出现的次数；
5. 开辟一个新的数组result，长度为待排序数组的长度，用于存储排序后的结果；
6. 遍历count数组，根据count数组中的信息将元素放入到result数组中对应的位置；
7. 返回result数组作为排序后的结果。

`时空复杂度`
计数排序的时间复杂度为O(n+k)，其中n为待排序数组的长度，k为数组中最大元素与最小元素的差值。计数排序的空间复杂度为O(k)。由于计数排序需要开辟一个长度为max-min+1的数组，因此当数组中元素取值范围过大时，计数排序的空间复杂度会比较高。
### 桶排序
`算法流程`
1. 初始化桶的容量，根据待排序元素个数计算桶的数量；
2. 遍历待排序数组，通过映射函数将每个元素分配到对应的桶中；
3. 分别对每个桶内元素排序；（可使用插入排序）
4. 遍历桶序列，依次将桶内元素取出，组成一个有序的序列；

桶排序的时间复杂度为O(n+k)，其中n是要排序的元素个数，k是桶的个数。空间复杂度为O(n+k)。当k远远小于n时，桶排序的时间复杂度接近O(n)。
### 基数排序
`算法流程`
1. 取得数组中的最大数，并取得位数；
2. 从最低位开始，依次进行排序。对于每一位的排序，用桶来进行计数排序，每个桶存放该位上相同的数；
3. 每一位排完序之后，将每个桶里的数字依次取出，重新放回数组中；
4. 排序完成后，数组中的数就按照从低位到高位的顺序排列好了。

 `时空复杂度`
1. 时间复杂度：O(d * (n + k))，其中d是数字位数，n是元素个数，k是桶的大小。在最坏情况下，需要遍历所有的元素，因此时间复杂度为O(n * d)。
2. 空间复杂度：O(n + k)，需要使用n个元素大小的数组和k个桶。
